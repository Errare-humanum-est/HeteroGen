/*
 * Copyright (c) 1999-2013 Mark D. Hill and David A. Wood
 * Copyright (c) 2021 Nicolai Oswald and The University of Edinburgh
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L1Cache, "Heterogeneous MESI-DeNovo Directory L1 Cache CMP")
 : Sequencer*   sequencer;

   CacheMemory* L1Icache;
   CacheMemory* L1Dcache;

   int l2_select_num_bits;
   Cycles l1_request_latency  := 2;
   Cycles l1_response_latency := 2;
   Cycles to_l2_latency       := 1;
   bool send_evictions;
   Cycles llsc_locked_duration := 128;

   // Message Queues
   // From this node's L1 cache TO the network

   // a local L1 -> this L2 bank, currently ordered with directory forwarded requests
   MessageBuffer* requestFromL1Cache, network="To", virtual_network="0",
        vnet_type="request";

   // a local L1 -> this L2 bank
   MessageBuffer* responseFromL1Cache, network="To", virtual_network="1",
        vnet_type="response";

   MessageBuffer* unblockFromL1Cache, network="To", virtual_network="2",
        vnet_type="unblock";

   // To this node's L1 cache FROM the network
   // a L2 bank -> this L1
   MessageBuffer* requestToL1Cache, network="From", virtual_network="2",
        vnet_type="request";

   // a L2 bank -> this L1
   MessageBuffer* responseToL1Cache, network="From", virtual_network="1",
        vnet_type="response";

  // Buffer for requests generated by the processor core.
  MessageBuffer* mandatoryQueue;

  // Buffer for unlock 
  MessageBuffer* triggerQueue;
{
  // STATES
  state_declaration(State, desc="Cache states", default="L1Cache_State_I") {
    // Base states
    I,           AccessPermission:Invalid,    desc="a L1 cache entry Idle";
    S,           AccessPermission:Read_Only,  desc="a L1 cache entry Shared";
    E,           AccessPermission:Read_Only,  desc="a L1 cache entry Exclusive";
    M,           AccessPermission:Read_Write, desc="a L1 cache entry Modified", format="!b";
    L,           AccessPermission:Read_Write, desc="a L1 cache entry Modified and locked";

    // Transient States
    IS,          AccessPermission:Busy,       desc="L1 idle, issued GETS, have not seen response yet";
    IM,          AccessPermission:Busy,       desc="L1 idle, issued GETX, have not seen response yet";
    IL,          AccessPermission:Busy,       desc="L1 idle, issued GETX, have not seen response yet, will be locked";
    SM,          AccessPermission:Read_Only,  desc="L1 idle, issued GETX, have not seen response yet";
    SL,          AccessPermission:Read_Only,  desc="L1 idle, issued GETX, have not seen response yet, will be locked";
    IS_I,        AccessPermission:Busy,       desc="L1 idle, issued GETS, saw Inv before data because directory doesn't block on GETS hit";

    E_I,         AccessPermission:Busy,       desc="Clean L1 replacing, waiting for ACK";
    M_I,         AccessPermission:Busy,       desc="Dirty L1 replacing, waiting for ACK";
    PUTI_WB_ACK, AccessPermission:Busy,       desc="L1 replacing, waiting for ACK";
    SINK_WB_ACK, AccessPermission:Busy,       desc="This is to sink WB_Acks from L2";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    // L1 events
    Load,            desc="Load request from the home processor";
    Ifetch,          desc="I-fetch request from the home processor";
    Store,           desc="Store request from the home processor";
    LL,              desc="Load-Linked";

    Inv,             desc="Invalidate request from L2 bank";
    WB_Req,          desc="Writeback request";

    // internal generated request
    L1_Replacement,  desc="L1 Replacement", format="!r";

    // other requests
    Fwd_GETX,        desc="GETX from other processor";
    Fwd_GETS,        desc="GETS from other processor";

    Ack,             desc="Ack for processor";
    Ack_all,         desc="Last ack for processor";

    PutM_Ack,          desc="Ack for replacement";
    PutI_Ack,          desc="Ack for replacement";

    GetM_Ack_C_to_C,    desc="Data for processor";
    GetM_Ack_D,         desc="Data for processor";
    GetM_Ack_A,         desc="Data for processor, waiting for Ack";
    GetS_Ack,           desc="Data for processor"; 

    // unlock
    Unlock,          desc="Unlock locked cacheline";
  }

  // TYPES

  // CacheEntry
  structure(Entry, desc="...", interface="AbstractCacheEntry" ) {
    State     CacheState,                  desc="cache state";
    DataBlock DataBlk,                     desc="data for the block";
    bool      Dirty,      default="false", desc="data is dirty";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr      addr,                         desc="Physical address for this TBE";
    State     TBEState,                     desc="Transient state";
    DataBlock DataBlk,                      desc="Buffer for the data block";
    bool      Dirty,       default="false", desc="data is dirty";
    int       pendingAcks, default="0",     desc="number of pending acks";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }

  TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";

  int l2_select_low_bit, default="RubySystem::getBlockSizeBits()";

  Tick clockEdge();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void wakeUpAllBuffers();
  void profileMsgDelay(int virtualNetworkType, Cycles c);

  // inclusive cache returns L1 entries only
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    if(is_valid(L1Dcache_entry)) {
      return L1Dcache_entry;
    }

    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  Entry getL1DCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    return L1Dcache_entry;
  }

  Entry getL1ICacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:I;
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    // MUST CHANGE
    if(is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(tbe.TBEState));
      return L1Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(cache_entry.CacheState));
      return L1Cache_State_to_permission(cache_entry.CacheState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  bool functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      return testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      return testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L1Cache_State_to_permission(state));
    }
  }

  Event mandatory_request_type_to_event(RubyRequestType stype, RubyRequestType ptype) {
    if (stype == RubyRequestType:LD) {
      return Event:Load;
    } else if (stype == RubyRequestType:IFETCH) {
      return Event:Ifetch;
    } else if ((stype == RubyRequestType:ST) ||
               (stype == RubyRequestType:ATOMIC) ||
               (stype == RubyRequestType:ATOMIC_NO_RETURN) ||
               (stype == RubyRequestType:ATOMIC_RETURN)) {
      if (ptype == RubyRequestType:Load_Linked) {
        return Event:LL;
      } else {
        return Event:Store;
      }
    } else {
      error("Invalid RubyRequestType");
    }
  }

  int getPendingAcks(TBE tbe) {
    return tbe.pendingAcks;
  }

  out_port(requestL1Network_out, RequestMsg, requestFromL1Cache);
  out_port(responseL1Network_out, ResponseMsg, responseFromL1Cache);
  out_port(unblockNetwork_out, ResponseMsg, unblockFromL1Cache);
  out_port(triggerQueue_out, RequestMsg, triggerQueue);

  // Trigger Queue for unlocking cachelines
  in_port(triggerQueue_in, RequestMsg, triggerQueue) {
    if (triggerQueue_in.isReady(clockEdge())) {
      peek(triggerQueue_in, RequestMsg) {
        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        trigger(Event:Unlock, in_msg.addr, cache_entry, tbe);
      }
    }
  }

  // Response  L1 Network - response msg to this L1 cache
  in_port(responseL1Network_in, ResponseMsg, responseToL1Cache, rank = 2) {
    if (responseL1Network_in.isReady(clockEdge())) {
      peek(responseL1Network_in, ResponseMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        // CACHE TO CACHE
        if(in_msg.Type == CoherenceResponseType:GETM_ACK_D_C_to_C) {
          assert(machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache ||
               machineIDToMachineType(in_msg.Sender) == MachineType:DeNovo);
          trigger(Event:GetM_Ack_C_to_C, in_msg.addr, cache_entry, tbe);

        // DIR TO CACHE
        } else if(in_msg.Type == CoherenceResponseType:GETM_ACK_D) {
          assert(machineIDToMachineType(in_msg.Sender) == MachineType:L2Cache);
          trigger(Event:GetM_Ack_D, in_msg.addr, cache_entry, tbe);

        } else if(in_msg.Type == CoherenceResponseType:GETS_ACK) {
          assert(machineIDToMachineType(in_msg.Sender) == MachineType:L2Cache);
          trigger(Event:GetS_Ack, in_msg.addr, cache_entry, tbe);

        } else if(in_msg.Type == CoherenceResponseType:GETM_ACK_AD) {
          if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {   
            trigger(Event:GetM_Ack_D, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:GetM_Ack_A, in_msg.addr, cache_entry, tbe);
          }

        } else if (in_msg.Type == CoherenceResponseType:GETM_ACK_A) {
          if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
          }

        } else if (in_msg.Type == CoherenceResponseType:INV_ACK) {
          if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
          } else {
            trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
          }
        } else if (in_msg.Type == CoherenceResponseType:PUTM_ACK) {
          trigger(Event:PutM_Ack, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceResponseType:PUTI_ACK) {
          trigger(Event:PutI_Ack, in_msg.addr, cache_entry, tbe);
        } else {
          error("Invalid L1 response type");
        }
      }
    }
  }

  // Request InterChip network - request from this L1 cache to the shared L2
  in_port(requestL1Network_in, RequestMsg, requestToL1Cache, rank = 1) {
    if(requestL1Network_in.isReady(clockEdge())) {
      peek(requestL1Network_in, RequestMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        if (in_msg.Type == CoherenceRequestType:INV) {
          trigger(Event:Inv, in_msg.addr, cache_entry, tbe);

        } else if (in_msg.Type == CoherenceRequestType:WB_REQ) {
          trigger(Event:WB_Req, in_msg.addr, cache_entry, tbe);

        } else if (in_msg.Type == CoherenceRequestType:GETX) {
          // upgrade transforms to GETX due to race
          trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);

        } else if (in_msg.Type == CoherenceRequestType:GETS) {
          trigger(Event:Fwd_GETS, in_msg.addr, cache_entry, tbe);

        } else {
          error("Invalid forwarded request type");
        }
      }
    }
  }

  // Mandatory Queue betweens Node's CPU and it's L1 caches
  in_port(mandatoryQueue_in, RubyRequest, mandatoryQueue, desc="...", rank = 0) {
    if (mandatoryQueue_in.isReady(clockEdge())) {
      peek(mandatoryQueue_in, RubyRequest, block_on="LineAddress") {

        // Check for data access to blocks in I-cache and ifetchs to blocks in D-cache

        if (in_msg.Type == RubyRequestType:IFETCH) {
          // ** INSTRUCTION ACCESS ***

          Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
          if (is_valid(L1Icache_entry)) {
            // The tag matches for the L1, so the L1 asks the L2 for it.
            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.PrimaryType),
                    in_msg.LineAddress, L1Icache_entry, TBEs[in_msg.LineAddress]);
          } else {

            // Check to see if it is in the OTHER L1
            Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
            if (is_valid(L1Dcache_entry)) {
              // The block is in the wrong L1, put the request on the queue to the shared L2
              trigger(Event:L1_Replacement, in_msg.LineAddress,
                      L1Dcache_entry, TBEs[in_msg.LineAddress]);
            }

            if (L1Icache.cacheAvail(in_msg.LineAddress)) {
              // L1 does't have the line, but we have space for it
              // in the L1 so let's see if the L2 has it.
              trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.PrimaryType),
                      in_msg.LineAddress, L1Icache_entry, TBEs[in_msg.LineAddress]);
            } else {
              // No room in the L1, so we need to make room in the L1
              trigger(Event:L1_Replacement, L1Icache.cacheProbe(in_msg.LineAddress),
                      getL1ICacheEntry(L1Icache.cacheProbe(in_msg.LineAddress)),
                      TBEs[L1Icache.cacheProbe(in_msg.LineAddress)]);
            }
          }
        } else {

          // *** DATA ACCESS ***
          Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
          if (is_valid(L1Dcache_entry)) {
            // The tag matches for the L1, so the L1 ask the L2 for it
            trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.PrimaryType),
                    in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
          } else {

            // Check to see if it is in the OTHER L1
            Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
            if (is_valid(L1Icache_entry)) {
              // The block is in the wrong L1, put the request on the queue to the shared L2
              trigger(Event:L1_Replacement, in_msg.LineAddress,
                      L1Icache_entry, TBEs[in_msg.LineAddress]);
            }

            if (L1Dcache.cacheAvail(in_msg.LineAddress)) {
              // L1 does't have the line, but we have space for it
              // in the L1 let's see if the L2 has it.
              trigger(mandatory_request_type_to_event(in_msg.Type, in_msg.PrimaryType),
                      in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
            } else {
              // No room in the L1, so we need to make room in the L1
              trigger(Event:L1_Replacement, L1Dcache.cacheProbe(in_msg.LineAddress),
                      getL1DCacheEntry(L1Dcache.cacheProbe(in_msg.LineAddress)),
                      TBEs[L1Dcache.cacheProbe(in_msg.LineAddress)]);
            }
          }
        }
      }
    }
  }

  // ACTIONS
  action(a_issueGETS, "a", desc="Issue GETS") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(ai_issueGETINSTR, "ai", desc="Issue GETINSTR") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GET_INSTR;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(b_issueGETX, "b", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETX;
        out_msg.Requestor := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(c_issueUPGRADE, "c", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg,  l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:UPGRADE;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.AccessMode := in_msg.AccessMode;
      }
    }
  }

  action(issuePUTX, "gissuePUTX", desc="send data to the L2 cache") {
    enqueue(requestL1Network_out, RequestMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:PUTX;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := true;
      out_msg.Requestor:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Data;
    }
  }

  action(issuePUTE, "gissuePUTE", desc="send data to the L2 cache") {
    enqueue(requestL1Network_out, RequestMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:PUTE;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := false;
      out_msg.Requestor:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Control;
    }
  }

  // RF response to Requestor cache
    action(send_GetM_Ack_ToRequestor, "cGETM_ToRequestor", desc="send data to requestor") {
      peek(requestL1Network_in, RequestMsg) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          assert(is_valid(cache_entry));
          out_msg.addr := address;
          out_msg.Type := CoherenceResponseType:GETM_ACK_D_C_to_C;
          out_msg.DataBlk := cache_entry.DataBlk;
          out_msg.Dirty := cache_entry.Dirty;
          out_msg.Sender := machineID;
          out_msg.Destination.add(in_msg.Requestor);
          out_msg.MessageSize := MessageSizeType:Response_Data;
        }
      }
    }

    action(send_GetM_Ack_ToRequestor_fromTBE, "cGETM_ToRequestor_fromTBE", desc="send data to requestor") {
      peek(requestL1Network_in, RequestMsg) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          assert(is_valid(tbe));
          out_msg.addr := address;
          out_msg.Type := CoherenceResponseType:GETM_ACK_D_C_to_C;
          out_msg.DataBlk := tbe.DataBlk;
          out_msg.Dirty := tbe.Dirty;
          out_msg.Sender := machineID;
          out_msg.Destination.add(in_msg.Requestor);
          out_msg.MessageSize := MessageSizeType:Response_Data;
        }
      }
    }

  // Response to Dir
    action(send_GetM_Ack_DD_to_Dir, "csend_GetM_Ack_DD_to_Dir", desc="send data to the L2 cache") {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:GETM_ACK_DD;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }

    action(send_GetM_Ack_DD_to_Dir_fromTBE, "csend_GetM_Ack_DD_to_Dir_fromTBE", desc="send data to the L2 cache") {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:GETM_ACK_DD;
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.Dirty := tbe.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }

    action(send_GetM_Ack_DC_to_Dir, "csend_GetM_Ack_DC_to_Dir", desc="send data to the L2 cache") {
      peek(requestL1Network_in, RequestMsg) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          out_msg.addr := address;
          out_msg.Type := CoherenceResponseType:GETM_ACK_DC;
          out_msg.Sender := machineID;
          out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                              l2_select_low_bit, l2_select_num_bits, intToID(0)));
          out_msg.MessageSize := MessageSizeType:Response_Control;
        }
      }
    }

    action(send_WB_DATA, "fsend_WB_DATA", desc="send data to the L2 cache") {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:WB_DATA;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }

    action(send_WB_DATA_fromTBE, "fsend_WB_DATA_fromTBE", desc="send data to the L2 cache") {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:WB_DATA;
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.Dirty := tbe.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }

    action(send_WB_CLEAN, "fsend_WB_CLEAN", desc="send data to the L2 cache") {
      peek(requestL1Network_in, RequestMsg) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          out_msg.addr := address;
          out_msg.Type := CoherenceResponseType:WB_CLEAN;
          out_msg.Sender := machineID;
          out_msg.Destination.add(in_msg.Requestor);
          out_msg.MessageSize := MessageSizeType:Response_Control;
        }
      }
    }

  action(fi_sendInvAck, "fi", desc="send data to the L2 cache") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:INV_ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
        out_msg.AckCount := 1;
      }
    }
  }

  action(forward_eviction_to_cpu, "\cc", desc="sends eviction information to the processor") {
    if (send_evictions) {
      DPRINTF(RubySlicc, "Sending invalidation for %#x to the CPU\n", address);
      sequencer.evictionCallback(address);
    }
  }


  action(dg_invalidate_sc, "dg",
         desc="Invalidate store conditional as the cache lost permissions") {
    sequencer.invalidateSC(address);
  }

  action(h_load_hit, "hd",
         desc="Notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Dcache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(h_ifetch_hit, "hi", desc="Notify sequencer the instruction fetch completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(hx_load_hit, "hx", desc="Notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(address);
    L1Dcache.setMRU(address);
    sequencer.readCallback(address, cache_entry.DataBlk, true);
  }

  action(hh_store_hit, "\h", desc="Notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Dcache.setMRU(cache_entry);
    sequencer.writeCallback(address, cache_entry.DataBlk);
    cache_entry.Dirty := true;
  }

  action(hhx_store_hit, "\hx", desc="Notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(address);
    L1Dcache.setMRU(address);
    sequencer.writeCallback(address, cache_entry.DataBlk, true);
    cache_entry.Dirty := true;
  }

  action(i_allocateTBE, "i", desc="Allocate TBE") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
  }

  action(k_popMandatoryQueue, "k", desc="Pop mandatory queue.") {
    mandatoryQueue_in.dequeue(clockEdge());
  }

  action(l_popRequestQueue, "l",
    desc="Pop incoming request queue and profile the delay within this virtual network") {
    Tick delay := requestL1Network_in.dequeue(clockEdge());
    profileMsgDelay(2, ticksToCycles(delay));
  }

  action(o_popIncomingResponseQueue, "o",
    desc="Pop Incoming Response queue and profile the delay within this virtual network") {
    Tick delay := responseL1Network_in.dequeue(clockEdge());
    profileMsgDelay(1, ticksToCycles(delay));
  }

  action(s_deallocateTBE, "s", desc="Deallocate TBE") {
    TBEs.deallocate(address);
    unset_tbe();
  }

  action(u_writeDataToL1Cache, "u", desc="Write data to cache") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.DataBlk := in_msg.DataBlk;
      cache_entry.Dirty := in_msg.Dirty;
    }
  }

  action(q_updateAckCount, "q", desc="Update ack count") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(tbe));
      tbe.pendingAcks := tbe.pendingAcks - in_msg.AckCount;
      APPEND_TRANSITION_COMMENT(in_msg.AckCount);
      APPEND_TRANSITION_COMMENT(" p: ");
      APPEND_TRANSITION_COMMENT(tbe.pendingAcks);
    }
  }

  action(ff_deallocateL1CacheBlock, "\f", desc="Deallocate L1 cache block.  Sets the cache to not present, allowing a replacement in parallel with a fetch.") {
    if (L1Dcache.isTagPresent(address)) {
      L1Dcache.deallocate(address);
    } else {
      L1Icache.deallocate(address);
    }
    unset_cache_entry();
  }

  action(oo_allocateL1DCacheBlock, "\o", desc="Set L1 D-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L1Dcache.allocate(address, new Entry));
    }
  }

  action(pp_allocateL1ICacheBlock, "\p", desc="Set L1 I-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L1Icache.allocate(address, new Entry));
    }
  }

  action(z_stallAndWaitMandatoryQueue, "\zm", desc="recycle L1 request queue") {
    stall_and_wait(mandatoryQueue_in, address);
  }

  action(z_stallAndWaitRequestQueue, "\zr", desc="recycle L1 request queue") {
    stall_and_wait(requestL1Network_in, address);
  }

  action(z_stall, "zs", desc="Stall the incoming request") {
    // do nothing
  }

  action(kd_wakeUpDependents, "kd", desc="wake-up dependents") {
    wakeUpBuffers(address);
  }

  action(kd_wakeUpAllDependents, "kda", desc="wake-up all dependents") {
    wakeUpAllBuffers();
  }

  action(uu_profileInstMiss, "\uim", desc="Profile the demand miss") {
      ++L1Icache.demand_misses;
  }

  action(uu_profileInstHit, "\uih", desc="Profile the demand hit") {
      ++L1Icache.demand_hits;
  }

  action(uu_profileDataMiss, "\udm", desc="Profile the demand miss") {
      ++L1Dcache.demand_misses;
  }

  action(uu_profileDataHit, "\udh", desc="Profile the demand hit") {
      ++L1Dcache.demand_hits;
  }

  action(su_scheduleUnlock, "su", desc="Schdule an unlock event") {
    assert(is_valid(cache_entry));
    enqueue(triggerQueue_out, RequestMsg, llsc_locked_duration) {
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:UNLOCK;
      out_msg.MessageSize := MessageSizeType:Control;
      DPRINTF(RubySlicc, "schedule to unlock line %#x at %s\n", address,
              ticksToCycles(clockEdge()) + llsc_locked_duration);
    }
  }

  action(pt_popTriggerQueue, "pT", desc="Pop the trigger queue") {
    triggerQueue_in.dequeue(clockEdge());
  }

  //*****************************************************
  // TRANSITIONS
  //*****************************************************

  // Transitions for Load/Store/Replacement/WriteBack from transient states
  transition({IS, IM, IL, IS_I, M_I, E_I, SM, SL, SINK_WB_ACK, PUTI_WB_ACK}, {Load, Ifetch, Store, LL, L1_Replacement}) {
    z_stallAndWaitMandatoryQueue;
  }

  // Transitions for Load/Store/Replacement/WriteBack from transient states
  transition({IS, IS_I, IM, IL, SM, SL}, {Fwd_GETX, Fwd_GETS, WB_Req}) {
    z_stallAndWaitRequestQueue;
  }

  // Transitions from Idle
  transition(I, L1_Replacement) {
    ff_deallocateL1CacheBlock;
  }

  transition(I, Load, IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    a_issueGETS;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  transition(I, Ifetch, IS) {
    pp_allocateL1ICacheBlock;
    i_allocateTBE;
    ai_issueGETINSTR;
    uu_profileInstMiss;
    k_popMandatoryQueue;
  }

  transition(I, Store, IM) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    b_issueGETX;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  transition(I, LL, IL) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    b_issueGETX;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  transition(I, Inv) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

  // Transitions from Shared
  transition({S,E,M,L}, Load) {
    h_load_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
  }

  transition({S,E,M,L}, Ifetch) {
    h_ifetch_hit;
    uu_profileInstHit;
    k_popMandatoryQueue;
  }

  transition(S, Store, SM) {
    i_allocateTBE;
    c_issueUPGRADE;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  transition(S, LL, SL) {
    i_allocateTBE;
    c_issueUPGRADE;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  transition(S, L1_Replacement, I) {
    forward_eviction_to_cpu;
    ff_deallocateL1CacheBlock;
  }

  transition(S, Inv, I) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    l_popRequestQueue;
  }

  // Transitions from Exclusive
  transition({E,M}, Store, M) {
    hh_store_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
  }

  transition({E,M}, LL, L) {
    su_scheduleUnlock;
    hh_store_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
  }

  // E
    transition(E, L1_Replacement, E_I) {
      // silent E replacement??
      forward_eviction_to_cpu;
      i_allocateTBE;
      issuePUTE;   // send data, but hold in case forwarded request
      ff_deallocateL1CacheBlock;
    }

    transition(E, WB_Req, I) {
      // don't send data
      forward_eviction_to_cpu;
      send_WB_CLEAN;
      l_popRequestQueue;
    }

    transition(E, Fwd_GETX, I) {
      forward_eviction_to_cpu;
      send_GetM_Ack_ToRequestor;
      l_popRequestQueue;
    }

    transition(E, Fwd_GETS, S) {
      send_GetM_Ack_ToRequestor;
      send_GetM_Ack_DD_to_Dir;                                  
      l_popRequestQueue;
    }

  // E_I
    transition(E_I, PutM_Ack, I) {
      s_deallocateTBE;
      o_popIncomingResponseQueue;
      kd_wakeUpDependents;
    }

    transition(E_I, PutI_Ack, PUTI_WB_ACK) {
      o_popIncomingResponseQueue;
    }

    transition(E_I, WB_Req, SINK_WB_ACK) {
      send_WB_CLEAN;
      l_popRequestQueue;
    }

    transition(E_I, Fwd_GETX, SINK_WB_ACK) {
      send_GetM_Ack_ToRequestor_fromTBE;
      l_popRequestQueue;
    }

    transition(E_I, Fwd_GETS, SINK_WB_ACK) {
      send_GetM_Ack_ToRequestor_fromTBE;
      send_GetM_Ack_DD_to_Dir_fromTBE;                     
      l_popRequestQueue;
    }

  // M
    transition(M, L1_Replacement, M_I) {
      forward_eviction_to_cpu;
      i_allocateTBE;
      issuePUTX;   // send data, but hold in case forwarded request
      ff_deallocateL1CacheBlock;
    }

    transition(M, WB_Req, I) {
      forward_eviction_to_cpu;
      send_WB_DATA;
      l_popRequestQueue;
    }

    transition(M, Fwd_GETX, I) {
      forward_eviction_to_cpu;
      send_GetM_Ack_ToRequestor;
      l_popRequestQueue;
    }

    transition(M, Fwd_GETS, S) {
      send_GetM_Ack_ToRequestor;
      send_GetM_Ack_DD_to_Dir;
      l_popRequestQueue;
    }

  //M_I
    transition(M_I, PutM_Ack, I) {
      s_deallocateTBE;
      o_popIncomingResponseQueue;
      kd_wakeUpDependents;
    }

    transition(M_I, PutI_Ack, PUTI_WB_ACK) {
      o_popIncomingResponseQueue;
    }


    transition(M_I, WB_Req, SINK_WB_ACK) {
      send_WB_DATA_fromTBE;
      l_popRequestQueue;
    }

    transition(M_I, Fwd_GETX, SINK_WB_ACK) {
      send_GetM_Ack_ToRequestor_fromTBE;
      l_popRequestQueue;
    }

    transition(M_I, Fwd_GETS, SINK_WB_ACK) {
      send_GetM_Ack_ToRequestor_fromTBE;
      send_GetM_Ack_DD_to_Dir_fromTBE;
      l_popRequestQueue;
    }

  // Transitions from Locked
  transition(L, {Store, LL}) {
    hh_store_hit;
    uu_profileDataHit;
    k_popMandatoryQueue;
  }

  transition(L, Unlock, M) {
    pt_popTriggerQueue;
    kd_wakeUpAllDependents;
  }

  transition(L, {Fwd_GETX, Fwd_GETS, WB_Req}) {
    z_stallAndWaitRequestQueue;
  }

  transition(L, L1_Replacement) {
    z_stall;
  }

  // Transitions from IS
  transition({IS, IS_I}, Inv, IS_I) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

  transition(IS, GetS_Ack, S) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS_I, GetS_Ack, I) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS, GetM_Ack_C_to_C, S) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS_I, GetM_Ack_C_to_C, I) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS, GetM_Ack_D, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // directory is blocked when sending exclusive data
  transition(IS_I, GetM_Ack_D, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Transitions from IM
  transition({IM, IL}, Inv) {
    fi_sendInvAck;
    l_popRequestQueue;
  }
  
  transition(IM, GetM_Ack_A, SM) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  transition(IM, {GetM_Ack_C_to_C, GetM_Ack_D}, M) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Transitions from IL
  transition(IL, GetM_Ack_A, SL) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  transition(IL, {GetM_Ack_C_to_C, GetM_Ack_D}, L) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    su_scheduleUnlock;
    kd_wakeUpDependents;
  }

  // Transitions from SM
  transition(SM, Inv, IM) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    dg_invalidate_sc;
    l_popRequestQueue;
  }

  transition({SM, IM, SL, IL}, Ack) {
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  transition(SM, Ack_all, M) {
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Transitions from SL
  transition(SL, Inv, IL) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    dg_invalidate_sc;
    l_popRequestQueue;
  }

  transition(SL, Ack_all, L) {
    hhx_store_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    su_scheduleUnlock;
    kd_wakeUpDependents;
  }
  
  // Transitions from SINK_WB_ACK
  transition(SINK_WB_ACK, Inv){
    fi_sendInvAck;
    l_popRequestQueue;
  }

  transition(SINK_WB_ACK, PutI_Ack, I){
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

    // PUTI_WB_ACK
    transition(PUTI_WB_ACK, Fwd_GETX, I) {
      send_GetM_Ack_ToRequestor_fromTBE;
      s_deallocateTBE;
      l_popRequestQueue;
      kd_wakeUpDependents;
    }

    transition(PUTI_WB_ACK, Fwd_GETS, I) {
      send_GetM_Ack_ToRequestor_fromTBE;
      send_GetM_Ack_DD_to_Dir_fromTBE;
      s_deallocateTBE;
      l_popRequestQueue;
      kd_wakeUpDependents;
    }

    transition(PUTI_WB_ACK, WB_Req, I) {
      send_GetM_Ack_DD_to_Dir_fromTBE;
      s_deallocateTBE;
      l_popRequestQueue;
      kd_wakeUpDependents;
    }

    transition(PUTI_WB_ACK, Inv){
      fi_sendInvAck;
      l_popRequestQueue;
    }

}
